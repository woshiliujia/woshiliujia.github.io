---
title: JavaScript-11-子集和扩展
date: 2019-05-07 17:40:39
tags: JavaScript
categories: JavaScript
---
## JavaScript子集
1. 为了安全运行第三方未知的代码，如广告
2. 规避语言的怪癖缺陷部分，使程序更健壮


## 常量和局部变量
关键字 "const" 可用来声明常量
常量不可重新赋值，不可重复声明（此种状况会报错，不管用cosnt或者var重新声明）

关键字 'let' 的四种使用方式
```
1 可以作为变量声明，和var一样;（没有变量提升，如果在使用let定义变量前使用则直接报错未定义）
2 for或者for/in循环中替代var方案，循环体外完全访问不到let定义的变量
3 在语句块中定义一个新的变量，并且显示指定它的作用域
4 定义一个在表达式内部作用域的变量，这个变量只能在表达式内部访问
```

## 解构和赋值
理解：等号右侧是一个数组或者对象，指定左侧一个或多个变量的语法和右侧数组或对象直接量的语法保持一致；当发生解构赋值时候右侧的数组或者对象中的一个或多个值就会被提取出来（解构） 并赋值给左侧对应的变量

注意：在左侧多了其他变量时候，就会被赋值undefined，右侧多则直接忽略


## 迭代

### for/each循环
each循环好像并不被支持，只有arr.forEach
for(let v in obj) 这种遍历的是对象的每个属性

### 迭代器
 迭代器是一个对象，并且必须包含next()方法，每一次调用next方法都返回集合中的下一个值
 例:
 ```
 function counter(start){
     let nextValue = Math.round(start);//迭代器的私有状态
     return {//迭代器返回必须是个对象
        next:function(){//并且迭代器必须包含一个next方法
            return nextValue++;//返回下一次的值
        }
     }
 }

 let count = counter(10);
 let s1 = count();//输出10
 let s2 = count();//输出11
 ```
 当迭代器用于有限的集合时，当迭代器遍历完所有值并且没有多余的值可迭代时。再调用next()方法会抛出 StopIteration(他是全局对象的一个属性，值是一个普通对象)只是为了终结迭代保留的一个对象


### 生成器
关键字 yield 在函数内部使用，用法和return类似，返回一个值。
区别：使用 yield 的函数产生一个可保持内部状态的值，这个值是可以恢复的

任何使用了yield的函数都称为生成器函数，可以使用return终止函数的执行，但是没有返回值
生成器函数和普通函数除了调用方式不同，其他相似。生成器函数返回的是一个生成器对象

生成器是一个对象，表示生成器函数当前执行的状态。它定义了一个next()方法，可恢复生成器的执行，直到下一条yiled语句
```

```

## 函数简写

## 多catch从句
```
try{
    //这里可能会抛出多种类型的异常
    throw 1;
}
catch(e if e instanceof RefrenceError){
    //这里处理引用类型错误
}
catch(e if === 'quit'){
    //处理抛出字符串是quit的情况
}
catch(e){
    //处理其余情况
}
finally{
    //finally从句正常执行
}
//如果有同个catch从句的条件成立，则跳过其它从句，如果一个从句都不满足则向上抛出未捕获异常
```

## E4X:ECMAScript for XML
...

