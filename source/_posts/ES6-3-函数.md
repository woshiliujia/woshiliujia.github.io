---
title: ES6-3-函数
date: 2019-08-22 15:17:25
tags: ES6
categories: ES6
---

## 带参数默认值的函数
es6中可以使用如下方式
```
function request(url,timeout = 2000,callback = function(){}){
    //剩余部分
    //此函数除url 必传其它参数都有默认值
}
```

### 参数默认值对arguments对象的影响
```
function test(first,second){
    "use strict" //表示严格模式
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = 1;
    secone = 2;
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}
/*
* 在非严格模式下，arguments 对象总是实时更新，因此 上面函数执行输出都是true
*
* 在严格模式下，arguments 对象不会被实时更新，因此函数输出最后2个是false
*/
```
es6中的函数默认值还有其它写法
```
funtion getValue(){
    return 5;
}
function add(first,second = getValue()){ //可以使用函数返回默认值
    return first + second;
}

function add(first,second = first){//可以使用前面的传入参数作为默认值
    return first + second;
}

function add(first = second,second){//错误的方式，因为second还未被定义
    return first + second;
}

console.log(add(1))
/**
* 1.默认值可以是函数返回的默认值
* 2.还可以使用传入参数作为默认是，不过需要注意 前面的不能引用后面的参数，因为引用时后面参数还未被定义
*/
```


### 参数默认值的暂时性死区
函数参数的暂时性死区与let const的暂时性死区一致，初始化之前都是无法被访问的。因此想要对函数第一个参数的默认值设置为第二个参数时候会报错，因为第二个参数尚未初始化

## 使用不具名参数
es6的剩余参数
```
function pick(object,...keys){
    console.log(keys);//keys是出object意外的参数，打印出来是个数组
}
//限制条件 1.函数只能有一个剩余参数，并且必须将剩余参数放在末尾
          2.剩余参数不能在对象字面量的setter属性中使用，会导致语法错误  如下

let obj = {
    //这会导致语法错误
    set name(...value){}
}
```
剩余参数和 arguments 对象总是能够正确返回函数的传入参数，也是为了方便函数可以不限制传入参数的数量

## 函数构造器的增强能力
在函数构造器 Function  支持了剩余参数  var pick = new Function('...key','return keys');

## 扩展运算符
允许将一个数组分割，比如取出数组中的最大值

PS:注意的地方
```
function pick(...keys){//此处的...keys 是函数的剩余的参数，是将多个独立的参数合成一个数组

}

const arr = [1,2,3,3,2,12,31];//去除数组中的最大值
Math.max(...arr);//次数的...arr 是将数组分割。并将各项作为单独的参数传入函数  返回31

//替代方法
Math.max.apply(Math,arr);//apply的区别
```

## ES6 的名称属性
```
function doSomeThing(){}  //doSomeThing.name doSomeThing

var doAnotherSomeThing = ()=>{}' //doAnotherSomeThing.name doAnotherSomeThing
```

### 名称属性的特殊情况
```
var person = {
    get firstName(){return 'Json'}
}
var descriptor = Object.getOwnPropertyDescriptor(preson,'firstName');
descriptor.get.name // 输出 firstName
//getOwnPropertyDescriptor获取的是属性的描述符（可读，可写，可配置，get，set）

var doSomeThing = function(){}
doSomeThing.bind().name;//输出 bound doSomeThing
//绑定产生的函数，拥有原函数的名称，不过前面总是带有 bound
```

## 明确函数的双重用途
在es5或者更早的版本中，函数会根据是否使用 new 关键字调用而有双重用途
当使用new关键字调用函数内部的this是一个新对象，并作为返回值

```
function Person(name){
    this.name = name;
}

var person = new Person('nico');
var notPerson = Person('nanc');

console.log(person);//[Object,Object] 生成的是一个新对象，也相当于this是函数返回值
console.log(notPerson);//undefined  因为普通函数调用，没有return返回值
```

js为函数提供了2个内部方法，[[Call]] 与 [[Construct]]。当函数未使用 new 关键字进行调用时 [[call]] 方法会被执行，如果使用new进行调用则执行[[Construct]]方法，负责创建一个新对象，并且使用新目标作为this，去执行函数体。即this指向的是新创建的对象。

PS：并不是所有的函数都拥有[[Construct]]方法，箭头函数中没有此内部方法

### 在es5中判断函数如何被调用   intanceof 方法并非绝对安全
```
function Person(name){
    if(this instanceof Person){
        this.name = name;
    }else{
        throw new Error('必须使用new关键字调用')
    }
}

var person = new Person('nico);
var notPerson = Person('nico');//抛错了 因为此处this指向的是全局作用域

var notPerson = Person.call(person,,'nico');//这种方法则会正常执行。
//对于函数来说，没有方法可以将这种方式与new调用区分
```

### new.target元属性
为了解决如何判断函数以何种方式被调用，es6引入了 new.target
元属性：非对象上的属性  例如 new的一个属性
```
function Person(name){
    if(typeof new.target !== 'undefined'){
        this.name = name;
    }else{
        throw new Error('必须使用new关键字调用');
    }
}
var person = new Person("Nicholas");
var notAPerson = Person.call(person, "Michael"); // 出错
```

## 箭头函数
#### 箭头函数与传统函数的区别
```
1.没有 this 、super 、 arguments 也没有new.target绑定：this super arguments

2.不能够被new调用：箭头函数内部没有 [[Construct]] 方法 

3.没有原型： 没有prototype属性，因为没有构造属性

4.不能更改this：this的值不能够被更改，在整个函数周期都保持不变

5.没有arguments对象：

6.不允许重复具名参数：
```

#### 语法
```
var sum = (num1,num2) => num1+num2; //写在一行的箭头函数不需要return关键字，默认返回 
//等价于
var sum = function(num1,num2){
    return num1+num2;
}
```
PS:如果箭头函数想要返回一个对象字面量，必须将该字面量包裹在圆括号内  这表示括号内是字面量，而且不是函数体
```
var getTempItem = id => ({id:id,name:'temp'});

//等价于

var getTempItem = function(id){
    return {id:id,name:'temp'}
}
```

### 创建立即调用函数表达式
箭头函数与传统函数 IIFE的区别
```
//传统函数圆括号技能包裹函数定义，也能连同参数一起调用
let fun = (function(){})() || (function(){}())

//箭头函数的IIFE不能将函数参数一起用圆括号包裹
let fun = (()=>{

})()
```

### 没有this
箭头函数中没有this绑定，this是根据它的上级来判定的

### 没有arguments绑定
箭头函数内部无arguments对象，但是可以访问到包含它的函数的arguments

### 尾调用优化
```
1.尾调用优化不能引用当前堆栈中的变量
2.尾调用的函数在调用结束后不能执行其他操作
3.尾调用的结果为当前函数的返回值
```
